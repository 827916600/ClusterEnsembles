# ClusterEnsembles.py
#   Author: Takehiro Sano
#   Contact: tsano430@gmail.com
#   License: MIT License


import numpy as np
import networkx as nx
import pymetis
from sklearn.metrics import pairwise_distances


def create_hypergraph(base_clusters):
    """Create the incidence matrix of base clusters' hypergraph
    
    Parameter
    ----------
    base_clusters: labels generated by base clustering algorithms
    
    Return
    -------
    H: incidence matrix
    """
    H = None
    bc_len = base_clusters.shape[1]

    for base_cluster in base_clusters:
        bc_types = np.unique(base_cluster[~np.isnan(base_cluster)])
        bc_types_len = len(bc_types)
        bc2id = dict(zip(bc_types, np.arange(bc_types_len)))
        h = np.zeros((bc_len, bc_types_len))
        for i, bc_elem in enumerate(base_cluster):
            if not np.isnan(bc_elem):
                h[i, bc2id[bc_elem]] = 1.0
        if H is None:
            H = h
        else:
            H = np.hstack([H, h])
    return H


def mcla(base_clusters, nclass):
    """Meta-CLustering Algorithm (MCLA)
    
    Parameters
    ----------
    base_clusters: labels generated by base clustering algorithms
    nclass: number of classes 
    
    Return
    -------
    celabel: concensus clustering label obtained from MCLA
    """
    H = create_hypergraph(base_clusters)
    H = H.astype(bool)

    pair_dist_jac = pairwise_distances(X=H.T, metric='jaccard', n_jobs=-1)
    S = np.ones_like(pair_dist_jac) - pair_dist_jac

    membership = pymetis.part_graph(nparts=nclass,  adjacency=nx.Graph(S))[1]

    meta_clusters = np.zeros((base_clusters.shape[1], nclass))
    for i, v in enumerate(membership):
        meta_clusters[:, v] += H[:, i]

    celabel = np.array([np.random.choice(np.nonzero(v == np.max(v))[0]) for v in meta_clusters])

    return celabel


def hbgf(base_clusters, nclass):
    """Hybrid Bipartite Graph Formulation (HBGF) 
    
    Parameters
    ----------
    base_clusters: labels generated by base clustering algorithms
    nclass: number of classes 
    
    Return
    -------
    celabel: concensus clustering label obtained from HBGF
    """
    A = create_hypergraph(base_clusters)
    rowA, colA = A.shape

    W = np.vstack([np.hstack([np.zeros((colA, colA)), A.T]), np.hstack([A, np.zeros((rowA, rowA))])])

    membership = pymetis.part_graph(nparts=nclass, adjacency=nx.Graph(W))[1]
    
    celabel = np.array(membership[colA:])

    return celabel


def cluster_ensembles(base_clusters, nclass=None, solver='hbgf', verbose=False):
    """Generate a single consensus cluster using base clusters obtained from multiple clustering algorithms
    
    Parameters
    ----------
    base_clusters: labels generated by base clustering algorithms
    nclass: number of classes 
    
    Return
    -------
    celabel: concensus clustering label obtained from HBGF
    """
    if nclass is None:
        nclass = len(np.unique(base_clusters[~np.isnan(base_clusters)]))

    if verbose:
        print('Cluster Ensembles')
        print('    - number of classes: ', nclass)
        print('    - solver: ', solver)
        print('    - length of base clustering labels: ', base_clusters.shape[1])
        print('    - number of base clusters: ', base_clusters.shape[0])

    if not (isinstance(nclass, int) and nclass > 0):
        raise ValueError('Number of class must be a positive integer; got (nclass={})'.format(nclass))

    if solver == 'mcla':
        celabel = mcla(base_clusters, nclass)
    elif solver == 'hbgf':
        celabel = hbgf(base_clusters, nclass)
    else:
        raise ValueError("Invalid solver parameter: got '{}' instead of one of ('cspa', 'mcla', 'hbgf')".format(solver))

    return celabel
